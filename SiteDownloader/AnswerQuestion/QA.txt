<Theme> TOP Вопросы на засыпку      
    
 <Question> 10. «Какие типы можно использовать в предложении foreach?» 
 <Answer> Массивы, коллекции.Классы в которых реализован интерфейс System.Collections.IEnumerable.
 <Question> 9. «В чем различие между классом и структурой ?» - 
 <Answer> Для С# классы System.Object, System.Exception, System.File-Stream и System.Random — это ссылочные типы (память выделяется из упр. кучи). В свою очередь размерные типы в документации называются структурами (structure) и перечислениями (enumeration). Например, структуры System.In132, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.10.FileAttributes и System.Drawing.FontStyle являются размерными типами (хранятся обычно в стеке потока, но могут быть встроены в ссылочные типы).
 <Question>8. «Что означает модификатор virtual?».
 <Answer>При наследовании класса. Данный метод м.б. переопределен в производных классах с помощью ключевого слова override.
 <Question>7. «Чем отличается event от delegate?»
 <Answer>Delegate – это по сути указатель на функцию<br>В С# модель издатель — подписчик, где класс публикует событие, которое он может инициировать, и любые классы могут подписаться на это событие. Метод, вызываемый при возникновении события, определяется делегатом
 <Question>6. «Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы? Каким образом?» 
 <Answer>Да. <br>public class GiuseppePizzaria : IWindow, IRestaurant {<br>// Реализация метода GetMenu интерфейса IWindow.<br>Object IWindow.GetMenu() { ... }<br>// Реализация метода GetMenu интерфейса IRestaurant.<br>Object IRestaurant.SetMenu() { ... }<br>// Метод GetMenu, не относящийся к интерфейсам. 
 <Question>5. «Что такое GAC?» 
 <Answer>Global Assembly Cache
 <Question>4. «В чем разница инкапсуляции и сокрытия?» 
 <Answer>Инкапсуляция предполагает формирование классов, т.е. размещение в одном месте сразу и структур данных, и методов. Инкапсуляция также предполагает установку области видимости структур данных и методов от использования их вне класса, в частности сокрытие данных и методов использую private.
 <Question>3. «Что такое частные и общие сборки?» -. 
 <Answer>Частные находятся в каталоге программы, а общие в GAC
 <Question>2. «Что такое .Net Framework?» 
 <Answer>Общеязыковая исполняющая среда common language runtime (CLR) + и библиотека классов framework class library (FCL).
 <Question>1. «Чем managed code отличается от unmanaged code?» -
 <Answer>Это означает, что CLR заботится об управлении памятью, о совместимости между платформами, о безопасности кода и так далее Это хорошо описано у Рихтера. <br><a name="cutid1-end"></a><br><a name="cutid2"></a><br>
    
 <Theme> Общие вопросы    
    
 <Question> 1.Поддерживает ли C# множественное наследование?
 <Answer>gdr_live: С# поддерживает множественное наследование в виде наследования от класса и нескольких интерфейсов, или просто от нескольких интерфейсов.<br>Но не поддерживает наследование от нескольких классов. 
 <Question>2. Кому доступны переменные с модификатором protected на уровне класса?
 <Answer>Любому классу-наследнику.
 <Question>3. Наследуются ли переменные с модификатором private?
 <Answer>Да, но они не являются доступными. 
 <Question>4. Опишите модификатор “protected internal”.
 <Answer>Члены с таким модификатором доступны классам, находящимся в той же сборке и унаследованным от данного класса.
 <Question>5. Назовите класс .NET, от которого наследуются все классы?
 <Answer>System.Object.
 <Question>6. Что обозначает термин immutable (неизменяемый)?
 <Answer>Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом заметьте, что значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены.<br>Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти. Пример тип String
 <Question>7. Какая разница между классами System.String и System.Text.StringBuilder?
 <Answer>Данные, хранящиеся в классе System.String и есть неизменяемые (immutable). Класс System.StringBuilder разрабатывался так, чтобы над изменяемой строкой можно было проделать множество операций. То есть при каждой операции над объектом класса System.String происходит перенос данных в новую область памяти, что влияет на производительность программы.
 <Question>8. Какое преимущество использования класса System.Text.StringBuilder перед System.String?
 <Answer>Класс StringBuilder более эффективен в случае работы с большим количеством строк. Объекты класса System.String неизменяемы, поэтому при каждом изменении строки создаётся новый объект в памяти.
 <Question>9. Можно ли хранить разные типы данных в объекте класса System.Array?
 <Answer><span><a href="http://az-spb-ru.livejournal.com/profile" rel="nofollow"><img height="16" src="http://l-stat.livejournal.com/img/userinfo.gif?v=104.3" width="16"></a><a href="http://az-spb-ru.livejournal.com/" rel="nofollow"><b>az_spb_ru</b></a></span><br><pre>static void Main(string[] args) {
      object[] arr = new object[] { "string", 0, new Guid() };
      foreach (object var in arr)
      {
    Console.WriteLine(var.GetType().ToString());
      }
      Console.ReadKey();
      double d = 0.0;
      ValueType[] arr2 = new ValueType[] { d, 0, new Guid() };
      foreach (ValueType var in arr2)
      {
    Console.WriteLine(var.GetType().ToString());
      }
      Console.ReadKey();
  } 
  </pre>
 <Question>10. Объясните разницу между System.Array.CopyTo() и System.Array.Clone()?
 <Answer>Первая операция осуществляет глубокое копирование массива, а вторая – поверхностное.Поверхностное копирование массива копирует только сами элементы объекта класса Array, независимо от того являются они ссылочными или значимыми типами.<br>Копирования объектов, на которые ссылаются ссылочные типы не происходит.Ссылки в новом объекте класса Array указывают на те же объекты, что и ссылки в оригинальном массиве Array.Глубокое копирование копирует как элементы класса Array, так и объекты, на которые они явно или неявно ссылаются.
 <Question>11. Как отсортировать элементы массива в убывающем порядке?
 <Answer>Нужно вызвать метод Sort(), а затем метод Reverse().
 <Question>12. Какой класс коллекций в .NET позволяет получить доступ к элементу с использованием уникального ключа?
 <Answer>HashTable.
 <Question>13. Какой класс используется в реализации класса SortedList?
 <Answer>Этот класс является гибридом классов HashTable и Array.
 <Question>14. Будет ли выполнен блок finally, если не было сгенерировано исключение?
 <Answer>Да.
 <Question>15. Какой синтаксис нужно использовать в C# для отлова любого возможного исключения?
 <Answer>Блок catch, отлавливающий исключения типа System.Exception. Также можно просто использовать catch{}, не указывая тип исключения.
 <Question>16. Можно ли выполнить несколько блоков catch дляодного оператора try?
 <Answer>Нет. Как только отработал один блок, управление передаётся в блок finally (если такой есть).
 <Question>17. Назовите три составных части модели известной как трёхуровневое приложение.
 <Answer>БД-серверная часть – клиент
 <Question>18. As, is – что это, как применяется?
 <Answer>Операторы приведения типов.<br>If(o is Employee){<br>Employee e = (Employee) o;<br>}<br>Проверка типа осущ., 2-ды. По этому в CLR<br>Employee e = o as Employee;<br>If(e != null){<br>}
 <Question>19. Какое место в иерархии типов .net занимает CString 
 <Answer>System.String, CString это из MFC
 <Question>20. Как реализованы в .Net простые типы: (вроде int etc...) 
 <Answer>marat_yuldashev: В виде структур<a name="cutid2-end"></a><br><a name="cutid3"></a><br>
      
 <Theme>Вопросы по классам



  
 <Question>1. Какой синтаксис используется для указания класса родителя в C#?
 <Answer>После имени класса наследника нужно поставить двоеточие и указать имя базового класса.<br>Пример: class ChildClass : ParentClass
 <Question>2. Можно ли запретить наследование от своего собственного класса?
 <Answer>Да. Для этого служит ключевое слово “sealed”.
 <Question>3. Можно ли разрешить наследование класса, но запретить перекрытие метода?
 <Answer>Да. Указываем класс как public, а метод как sealed.
 <Question>4. Что такое абстрактный класс?
 <Answer>Это класс, объект которого не может быть создан. Такой класс должен иметь класс-наследник с реализацией абстрактных методов. Абстрактный класс – это фактически чертёж нормального класса без реализации.
 <Question>5. В каком случае вы обязаны объявить класс абстрактным?
 <Answer>1. В том случае, если класс является наследником абстрактного класса, но не все методы базового класса перекрыты и имеют реализацию.<br>2. В том случае, если хотя бы один метод класса является абстрактным.
 <Question>6. Что такое интерфейс класса?
 <Answer>Интерфейсы, как и классы, определяют набор свойств, методов и событий. Но, в отличие от классов, они не содержат их реализации. Интерфейсы реализуются классами и определяются как самостоятельные сущности.
 <Question>7. Почему нельзя указать модификатор видимости для методов интерфейса?
 <Answer>Потому что все они должны иметь модификатор public, который и установлен по умолчанию.
 <Question>8. Можно ли наследовать от нескольких интерфейсов?
 <Answer>Да. .NET поддерживает такое наследование.
 <Question>9. Назовите отличия между интерфейсом и абстрактным классом?
 <Answer>В интерфейсе все методы (свойства и т.д.) абстрактны и не имеют реализации. В абстрактном классе некоторые методы могут быть реализованы. В интерфейсе члены не могут иметь модификатора видимости (все они являются public по умолчанию), а в абстрактном классе члены могут иметь модификатор видимости.
 <Question>10. Назовите различия между структурами и классами.
 <Answer>Для С# классы System.Object, System.Exception, System.File-Stream и System.Random — это ссылочные типы (память выделяется из упр. кучи). В свою очередь размерные типы в документации называются структурами (structure) и перечислениями (enumeration). Например, структуры System.In132, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.10.FileAttributes и System.Drawing.FontStyle являются размерными типами (хранятся обычно в стеке потока, но могут быть встроены в ссылочные типы).
 <Question>11. Назовите концепции ООП.
 <Answer>Концепции ООП строятся на базе трех основных принципов: 1) инкапсуляция 2)наследование 3)полиморфизм. <br>Инкапсуляция – это совмещение структур данных с функциями (методами), манипулирующими этими данными. Фактически, инкапсуляция предполагает размещение в одном месте сразу и структур данных, и методов.<br>Наследование – это создание новых классов, которые строятся на базе структур данных и методов уже существующих классов (базовых). В качестве примера рассмотрим windows-окно. Сначала строится класс стандартного windows-окна. <br>Полиморфизм – это использование одного имени или идентификатора для метода внутри одной иерархии класса таким образом, чтобы для разных классов этой иерархии этот метод реализовывал различные операции. Функция становится виртуальной, если перед ее объявление поставить спецификатор «virtual».
 <Question>12. В чем разница между абстрактными и виртуальными классами? Между виртуальными и абстрактными методами?
 <Answer>Абстрактный класс это класс, содержащий хотя бы один метод (abstract)..<br>Виртуальный метод имеет реализацию и м.б. переопределен в производном классе. Абстрактный метод не имеет реализацию, только описание метода, который д.б. реализован в производных классах. 
 <Question>13. Dispose(), Finalize() – что это за методы, как используются в .NET? 
 <Answer>Используются для освобождения ресурсов. Применяя метод Dispose, вы должны обеспечить неявную очистку методом Finalize. Если программисту не удалось вызвать метод Dispose, использование метода Finalize предотвращает постоянную утечку ресурсов.
 <Question>14. Для чего в .NET используется конструкция using(…){…}? Причем тут IDisposable?
 <Answer>Значение Using непосредственно связано с интерфейсом IDisposable. Интерфейс IDisposable представляет нам возможность быстро освободить общие ресурсы, не полагаясь на автоматический сборщик мусора (garbage collector).<br>Конструкция Using позволяет вызывать метод Dispose автоматически, как только нужный объект выйдет за блок Using.<a name="cutid3-end"></a><br><a name="cutid4"></a><br>
      
 <Theme>Вопросы по методам и свойствам



  
 <Question>1. Назовите явное имя параметра, передаваемого в метод set свойства класса?
 <Answer>value.Тип этого параметра определяется типом свойства.
 <Question>2. Что обозначает ключевое слово “virtual” для метода или свойства?
 <Answer>То, что метод или свойство может быть перекрыто.
 <Question>3. Чем перекрытый метод отличается от перегруженного метода?
 <Answer>При перекрывании метода мы изменяем его поведение в классе наследнике.Перегрузка метода просто приводит к использованию другого метода с тем же именем внутри класса.
 <Question>4. Можно ли объявить перекрытый метод статическим, если перекрываемый метод не является статическим?
 <Answer>Нет.Сигнатура виртуального метода должна остаться постоянной, кроме замены ключевого слова virtual на ключевое слово override.
 <Question>5. Какими способами может быть перегружен метод?
 <Answer>Другой тип параметров, другое количество параметров, другой порядок параметров.Фактически всё может быть другим, кроме имени.
 <Question>6. Если в базовом классе существует несколько перегруженных конструкторов и в классе-наследник есть несколько перегруженных конструкторов, можно ли вызвать конструктор базового класса из конструктора класса-наследника?
 <Answer>Да, можно.<a name = "cutid4-end" ></ a >< br >< a name= "cutid5" ></ a >< br >

 <Theme> События и делегаты



  
 <Question>1. Что такое делегат?
 <Answer>Делегат – это объект, инкапсулирующий ссылку на метод. Аналог указатель указателя на функцию
 <Question>2. Что такое групповой делегат?
 <Answer>Делегаты сами по себе невероятно полезны, но поддержка цепочек делает их еще полезнее.Я уже сказал, что у каждого объекта MulticastDelegate есть закрытое поле _prev.В этом поле хранится ссылка на другой объект MulticastDelegate, т.е.каждый объект типа MulticastDelegate (и любого типа, производного от него) обладает ссылкой на другой объект-потомок MulticastDelegate.Это поле позволяет объекту делегата становиться частью связного списка.<a name = "cutid5-end" ></ a >< br >< a name= "cutid6" ></ a >< br >

 <Theme> Вопросы по XML-документации



  
 <Question>1. Является ли XML регистрочувствительным (т.е.различает ли он прописные и строчные буквы)?
 <Answer>Да.
 <Question>2. Какая разница между комментариями
 <Answer>//комментарий,<br>/*комментарий*/ и<br>///комментарий?<br>Комментарий, который располагается на одной строке, на нескольких строках и комментарий для XML-документации.
 <Question>3. Как можно сгенерировать документацию из файла на C#, содержащего корректно сформированные комментарии с помощью компилятора командной строки?
 <Answer>Опция /doc: компилятора C#<br>CSC.exe<a name="cutid6-end"></a><br><a name="cutid7"></a><br>
  
 <Theme>Вопросы по отладке и тестированию



  
 <Question>1. Какие инструменты отладки входят в.NET SDK?
 <Answer>CorDBG – отладчик командной строки.Для использования этой утилиты нужно скомпилировать файл C# с ключом /debug.<br>DbgCLR – отладчик с графическим интерфейсом. Visual Studio .NET использует DbgCLR.
 <Question>2. Каково различие между классами Debug и Trace?
 <Answer>Документация выглядит одинаково. Однако, рекомендуется использовать класс Debug для сборки в режиме отладки, а Trace – как для отладки, так и для окончательной сборки.
 <Question>3. Зачем в классе System.Diagnostics.TraceSwitcher нужны пять уровней трассировки?
 <Answer>Дампы трассировки могут быть очень большими. Отсюда возникает риск нехватки места на диске для постоянно работающих приложений. Пять уровней трассировки от None (ничего) до Verbose (всё) позволяют настроить хранящуюся трассировочную информацию точно в соответствии с нашими нуждами.
 <Question>4. Куда перенаправляется вывод класса TextWriter-TraceListener?
 <Answer>На консоль или в текстовый файл, в зависимости от параметра, переданного конструктору.
 <Question>5. Каким образом происходит отладка приложения ASP.NET?
 <Answer>Путем подсоединения процесса aspnet_wp.exe к отладчику DbgClr.
 <Question>6. Какие три типа тестов вы должны выполнить в процессе тестирования сборки?
 <Answer>1. Позитивный тест (корректные данные – корректный вывод).<br>2. Негативный тест (некорректные или неполные данные – корректная обработка).<br>3. Исключительный тест (генерация исключений и их корректная обработка).
 <Question>7. Можно ли изменить значение переменной во время отладки приложения C#?
 <Answer>Да. 
 <Question>8. Что выведет этот код (чур в студию не подглядывать! :):
 <Answer>---<br>XmlDocument x = new XmlDocument();<br>x.LoadXml(" ");<br>Console.WriteLine(x.ToString());<br>Console.ReadKey();<br>---<br>marat_yuldashev: пример тип – объект - string<br><a name="cutid7-end"></a><br><a name="cutid8"></a><br>
      
 <Theme>Вопросы по ADO.net и БД



  
 <Question>1. Какова роль класса DataReader в ADO.NET?
 <Answer>Этот класс возвращает набор данных, доступный только для чтения с навигацией только вперёд. DataReader – самый быстрый способ получения данных.
 <Question>2. Какие преимущества и недостатки классов-поставщиков данных, предлагаемых Microsof в ADO.NET?
 <Answer>Поставщик данных SQLServer.NET – высокоскоростной и устойчивый, но для него необходима лицензия на SQL Server от Microsoft. OLE-DB.NET является универсальным поставщиком для доступа к данным из других источников, таких как Oracle, DB2, Microsoft Access и Informix. OLE-DB.NET – это.NET-слой поверх слоя OLE, поэтому он не так быстр и эффективен, как SqlServer.NET.
 <Question>3. Назовите групповой символ в SQL?
 <Answer>Если мы хотим сделать запрос к БД с LIKE для всех работников, чьё имя начинается с La, то групповым символом будет %, соответственно параметром для LIKE будет ‘La%’.
 <Question>4. Расскажите о правиле ACID для транзакций.
 <Answer>Транзакция должна быть:<br>1. Атомарной (Atomic) – результат её работы не должен зависеть от предыдущих и следующих транзакций.<br>2. Согласованной (Consistent) – данные или записаны или не записаны, не должно быть промежуточного состояния после окончания транзакции.<br>3. Изолированность (Isolated) – транзакции не видят промежуточных результатов текущей транзакции.<br>4. Надёжность (Durable) – значения сохраняются, если данные записаны, а система рушится сразу после этого.
 <Question>5. Какие соединения поддерживаются Microsoft SQL Server?
 <Answer>Соединения с аутентификацией Windows (посредством Active Directory) и SQL Server(через имя пользователя и пароль Microsoft SQL Server).
 <Question>6. Если сравнивать аутентификацию Windows и SQL Server, какое из них будет доверенным, а какое – нет?
 <Answer>Аутентификация Windows является доверенной, поскольку пароль и имя пользователя проверяются Active Directory, а аутентификация SQL Server не является доверенной, поскольку только SQL Server проверяет логин и пароль, принимающие участие в транзакции.
 <Question>7. Какое значение имеет параметр Initial Catalog в строке соединения?
 <Answer>Имя базы данных, к которой происходит подсоединение.
 <Question>8. Какими являются требования для использования пула соединений?
 <Answer>???

 <Theme> Вопросы по сборкам



  
 <Question>1. Каким образом в.NET решена проблема «DLL Hell»?
 <Answer>GAC.
 <Question>2. Каким образом можно распространять сборки?
 <Answer>2 вида сборок со строгим(с ключом) и нестрогим именем. 
 <Question>3. Что такое «сопутствующая сборка» (satellite assembly)?
 <Answer>Сборки, помеченные определенными региональными стандартами, называются<br> сателлитными сборками
 <Question>5. Какая наименьшая исполнимая единица в.NET?
 <Answer>сборка
 <Question>6. Когда необходимо вызывать сборщик мусора в .NET?
 <Answer>Вызывается автоматически. 
 <Question>7. Как конвертировать значимый тип в ссылочный?
 <Answer>Int32 x = 5;<br>Object о = x;
 <Question>8. Что происходит в памяти при упаковке и распаковке значимого типа?
 <Answer>При упаковке экземпляра размерного типа происходит следующее.<br>1. В управляемой куче выделяется память.Ее объем определяется длиной размерного типа и некоторыми накладными расходами, позволяющими этому размерному типу стать настоящим объектом.Этими накладными расходами являются указатель на таблицу методов и индекс SyncBlocklndex.<br>2. Поля размерного типа копируются в память, выделенную только что в куче.<br>3. Возвращается адрес объекта.Этот адрес является ссылкой на объект; размерный тип превратился в ссылочный.<br>Распаковка не является точной противоположностью упаковки.<br>Она состоит только в получении указателя на исходный. <br>размерный тип (поля данных), содержащийся в объекте.И никакого копирования при распаковке (в отличие от упаковки). Однако обычно вслед за распаковкой выполняется копирование полей, поэтому в сумме обе эти операции являются отражением операции упаковки<a name="cutid9-end"></a></div>"
  
  
  =====================
  
  <Question>Что такое GAC?
<Answer>GAC — это глобальный кэш сборок. В нем хранятся совместно используемые сборки. Обычно это каталог С:\Windows\Assembly\GAC. Этот каталог имеет определенную структуру, в котором хранятся подкаталоги, имена которых сгенерированы по определенному алгоритму.
В GAC можно поместить только сборки со строгими именами. Для того, чтобы поместить сборку в GAC, используют специальный инструмент GACUtil.exe, который знает всю внутреннюю структуру GAC и может генерировать имена подкаталогов надлежащим образом.
Регистрировать в GAC сборки необходимо для того, чтобы избежать конфликтов имен сборок. 
Приведем пример: две компании выпустили сборку и назвали ее одним именем Calculus. Если мы скопируем эту сборку в каталог, в котором уже находится сборка с таким же именем, то мы затрем сборку, которая ранее могла использоваться каким-то приложением. 
Это приложение с новой сборкой теперь работать не сможет. 
Решением этой проблемы будет регистрация этих двух сборок в GAC, в котором для каждой будет создан отдельный каталог.
<Question>Что такое Boxing и Unboxing?
<Answer>Упаковка (boxing) позволяет преобразовать размерный тип в ссылочный. При упаковке объекта размерного типа происходят следующие действия:
1. Выделяется память в управляемой куче.
2. Совершается копирование полей размерного типа в память, которая была выделена в куче.
3. Возвращается адрес объекта.
Некоторые компиляторы автоматически создают IL-код, необходимый для упаковки объекта размерного типа.
Процесс извлечения адреса полей из упакованного объекта называется распаковкой (unboxing). Распаковка не является полной противоположностью упаковке. В отличие от упаковки при распаковке не происходит никакого копирования. Однако обычно вслед за распаковкой следует копирование полей, поэтому обе операции (распаковка и копирование) являются противоположностью операции упаковки.
Приведем пример использования упаковки и распаковки.
<pre>
// Объявляем размерный тип.
struct Point {
public Int32 x, у;
}


class App {
static void Main() {
ArrayList a = new ArrayList();
Point p; 		 	// Выделяется память для Point (не в куче).
for (Int32 i = 0 ; i &lt; 10; i++) {
p.x = p. у = i; 	// Инициализация членов в нашем размерном типе.
a.Add(p); 	 	// Упаковка размерного типа и добавление ссылки в ArrayList.
	}


	Point р1 = (Point) [0]; 	// распаковка и копирование полей
}
</pre>
Упаковка и распаковка/копирование снижают производительность приложения как в плане замедления, так и в расходе дополнительной памяти, поэтому нужно стараться минимизировать создание кода, в котором происходят операции упаковки и распаковки/копирования.
<Question>Что такое Reflection?
<Answer>Отражение (reflection) — это механизм, предоставляющий исполняемому коду информацию о самом себе. Отражение позволяет методу изучать чужой код и изменять свою работу в соответствии с полученными данными.  Также отражение может применяться, когда метод должен выполнять разные действия в зависимости от того, откуда он запущен.
Рассмотрим простой пример:
<pre>
public class Animal
{
    public void Eat() 
    {
       Console.WriteLine(''The animal eats.''); 
    }
}


Animal an = new Animal();
an.Eat();




Type animalType = typeof(Animal);


if(animalType != null)
{
	ConstructorInfo ci = animalType.GetConstructor(new Type[]{});
	object animalReflected = ci.Invoke(new object[]{});
}
</pre>
В этом примере объявляется класс Animal с одним методом — Eat.
Далее создается экземпляр класса и вызывается метод Eat.
После этого делается попытка получить метаданные, описывающие класс Animal. Эти данные заносятся в переменную animalType.
Если данные получены, переменной ci мы присваиваем ссылку на конструктор.
Далее, используя отражение, вызывается конструктор, который возвращает ссылку на созданный объект.
Теперь мы можем привести переменную animalReflected к типу Animal и пользоваться методами этого класса напрямую.
<Question>В чем различие между Finalize и Dispose?
<Answer>Dispose - обеспечивает явный контроль над ресурсами, используемыми объектом, а Finalize - неявный, используемый сборщиком мусора.
<Question>Как обеспечить использование именованных параметров в конструкторе атрибута?
<Answer>Конструкторы атрибутов могут принимать именованные параметры — поля и свойства атрибутов. При задании именованного параметра в конструктор атрибута передается имя свойства или поля, которое должно принять этот параметр. При чем эти свойства и поля должны быть открытыми.
Если именованные параметры передаются, то они обязательно должны идти следом за позиционными параметрами, которые явно указаны в конструкторе атрибута.
Указание именованных параметров не является обязательным, поэтому при проектировании атрибутов необходимо помнить о том, что некоторые его поля или свойства могут быть не проинициализированы.
Пример использования именованных параметров в конструкторе атрибута:
[DllImport(''Kernel32'', CharSet=CharSet.Auto, SetLastError=true)]
Здесь передается 1 позиционный параметр — строка "Kernel32" и 2 именованных параметра, которые устанавливают открытые поля  CharSet и  SetLastError в значения  CharSet.Auto и true соответственно.
<Question>Что такое attribute?
<Answer>Атрибут (attribute) - это универсальное средство связи данных с типами, позволяют добавлять любую текстовую информацию о классах, свойствах, методах и т.д. Атрибуты сохраняются с метаданными и могут быть получены при выполнении программы.
<Question>Что такое Code Access Security (CAS)?
<Answer>CAS - это защитная технология, позволяющая установить ограничение на исполнение управляемого кода. Таким образом можно определить разрешения и установить права доступа к ресурсам компьютера.
<Question>Когда объект удаляется сборщиком мусора?
<Answer>Объект удаляется сборщиком мусора, когда на него не остается ссылок.
<Question>В чем различие между Value Type и Reference Type?
<Answer>Value Type находятся в стеке, а Reference Type в куче.
<Question>В чем разница между понятиями namespace и assembly?
<Answer>Namespace (пространство имен) является логическим соглашением, используемым во время разработки, в то время как assembly (сборка) устанавливает область видимости имени в процессе выполнения.
<Question>Что такое assembly manifest?
<Answer>Манифест сборки (assembly manifest) - это внутренняя часть сборки, которая позволяет ей быть самоописанной. Assembly manifest позволяет идентифицировать сборку, указывает файлы, которые включаются в реализацию сборки, описывает типы и ресурсы, используемые в сборке, указывает зависимости от других сборок, а также набор прав доступа, которые необходимы сборке для корректной работы. Эта информация используется во время выполнения для разрешения ссылок, проверку корректности версий, проверку целостности загруженных сборок.
<Question>Что такое приватные и совместные сборки?
<Answer>Сборки (assembly) бывают двух типов - приватные (private), которые использует только само приложение, и совместные (shared), использующиеся набором приложений.
При приватных сборках приложение изолируется от внешнего воздействия программ и операционной системы, отпадает необходимость заботиться об уникальности имен в глобальном пространстве имен.
Чтобы сделать сборку совместной, ее необходимо специальным образом собрать и присвоить ей строгое шифрованное имя.
<Question>Что такое assembly?
<Answer>Сборка (assembly) - один или несколько файлов, содержащий логический набор функциональности (код и другие данные, связанные с кодом). Бывают статические сборки, хранящиеся на диске, и динамические, которые создаются во время выполнения программы. Сборка - это базовый блок приложения, все ресурсы, относящиеся к ней, доступны или только внутри этого блока, или экспортируются наружу. При выполнении сборка задает область видимости имен и следит за ее соблюдением.
<Question>Что такое managed code?
<Answer>Управляемый код (managed code) - это код, работающий в среде CLR. Содержит метаданные, в которых находится информация для среды выполнения - о типах, членах и ссылках, используемых в коде.
<Question>Что такое CLR? Что такое IL? Что такое CLS?
<Answer>CLR (''Common Language Runtime'', ''общеязыковая исполняющая среда'') - это компонент .NET Framework, основной задачей которого является управление интерпретацией и исполнением кода IL. CLR отвечает за изоляцию памяти приложений, проверку типов, безопасность кода, преобразование IL в машинный код.

IL (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.

CLS (''Common Language Specification'', общеязыковая спецификация) - это набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

  
  
  
  
  ========
  
  
  <Question>1. Когда вызываются статические конструкторы классов в C#?
Один раз при первом создании экземпляра класса или при первом обращении к статическим членам класса
После каждого обращения к статическим полям, методам и свойствам
Строгий порядок вызова не определен
Статических конструкторов в C# нет
<Answer>В спецификации C# сказано:
The static constructor for a class executes at most once in a given application domain. The execution of a static constructor is triggered by the first of the following events to occur within an application domain:

An instance of the class is created.
Any of the static members of the class are referenced.

Потому самый близкий к истине ответ: "Один раз при первом создании экземпляра класса или при первом обращении к статическим членам класса". Хотя в данном случае наверное переформулировка "… при первом упоминании" будет более уместна.

Дело в том, что бывают статические конструкторы явные (когда конструктор задан явно) и неявные (присваивание значений статическим свойствам). В том случае, когда нет явно заданного статического конструктора, класс помечается флагом beforefieldinit, что говорит CLR о том, что инициализация статического поля произойдет до первого обращения к этому полю, причем она может произойти задолго до этого обращения.

Кстати, на этом свойстве статического конструктора построена одна из реализаций Singleton'а
<pre>
public sealed class Singleton
{
    static readonly Singleton instance = new Singleton();

    // Explicit static constructor to tell C# compiler
    // not to mark type as beforefieldinit
    static Singleton()
    {
    }

    Singleton()
    {
    }

    public static Singleton Instance
    {
        get
        {
            return instance;
        }
    }
}
</pre>

<Question>2. Каким образом можно перехватить добавление и удаление делегата из события?
Такая возможность не предусмотрена
Для этого существуют специальные ключевые слова add и remove
Использовать ключевые слова get и set
Переопределить операторы + и – для делегата
<Answer>Для подобных целей в C# предусмотрены ключевые слова add и remove. Их необходимо использовать аналогично get и set для свойств, то есть:
<pre>
public class MyClass {
  private EventHandler myEvent;
  public event EventHandler MyEvent
  {
    add { myEvent += value; }
    remove { myEvent -= value; }
  }
}
</pre>

<Question>3. Что произойдет при исполнении следующего кода? int i = 5; object o = i; long j = (long)o;
Ошибок не произойдет. Переменная j будет иметь значение 5
Произойдет ошибка времени компиляции
Средой исполнения будет вызвано исключение InvalidCastException
Значение переменной j предсказать нельзя
<Answer>int i = 5;
object o = i;
long j = (long)o;

Большая часть пользователей не знает правильного ответа на этот вопрос.

Будет сгенерировано исключение InvalidCastException (Исключение, которое выбрасывается при недопустимом приведении или явном преобразовании типов). Ошибка находится в третьей строчке. 

Приведение типов — это преобразование значения переменной одного типа в значение другого типа, бывает явным (explicit) и неявным (implicit):
int i = 123;
long l = (long)i;  // explicit 

int i = 123;
long l = i;  // implicit 

Существуют два вида типов: value-type и reference-type (типы-значения и типы-ссылки, соответственно), в тот момент, когда мы присваиваем переменной с ссылочным типом некоторое значение происходит boxing (упаковка) этого значения.
Boxing is the process of converting a value type to the type object or to any interface type implemented by this value type

Обратный процесс называется unboxing (распаковка).

Для того чтобы исправить ошибку достаточно изменить третью строчку long j = (int)o; Сначала будет произведен unboxing и возвращена переменная типа int, после чего будет вызван соответствующий implicit оператор.

<Question>4. Выберите средства, которые предоставляет C# для условной компиляции

Директива #if
Директива #endif
Директива #else
Директива #typedef
Директива #define
Атрибут Conditional
Директива #elseif
<Answer>
Все, кроме директивы #typedef и #elseif.

+UPD
С помощью #define нельзя писать макросы, как, например, в С++, но можно устанавливать значения. Директивами #if, #else, #endif проверяется, установлено ли значение. Атрибут Conditional служит для указания компилятору компилировать или не компилировать метод, в зависимости от того установлено ли соответствующее значение #define, что нужно исключить из сборки все вызовы данного метода. Сам метод останется в сборке и его можно будет вызвать с помощью Reflection.

Пример с использованием Conditional
#define TRACE_ON
using System;
using System.Diagnostics;

public class Trace
{
    [Conditional("TRACE_ON")]
    public static void Message(string msg)
    {
        Console.WriteLine(msg);
    }
}

[Conditional("DEBUG")]
public void Test()
{
    MessageBox.Show("I want cookie");
}
ctor()
{
    this.Test();
    this.GetType().InvokeMember("Test", BindingFlags.InvokeMethod, null, this, null);
}


<Question>5. Выберите правильные варианты, в которых пространство имен System содержит пространство имен Customizer

namespace System { namespace Customizer { } }
namespace System.Customizer { }
namespace System::Customizer { }
Нельзя создавать собственные пространства имен в пространстве имен System
<Answer>В C# создавать вложенные пространства имен можно либо написав их имена через точку, либо вложив одно в другое с помощью составного оператора { }.

<Question>6. Чтобы использовать unsafe код в приложении, необходимо …
Компилировать код приложения с ключом /unsafe
Пометить методы, где используется небезопасный код с помощью ключевого слова fixed
Пометить методы, где используется небезопасный код с помощью ключевого слова unsafe
Пометить методы, где используется небезопасный код атрибутом Unsafe
<Answer>Чтобы использовать unsafe код необходимо вызывать компилятор с ключом /unsafe, этот ключ также можно установить в настройках проекта. Помимо этого каждый метод с unsafe кодом необходимо пометить ключевым словом unsafe.

<Question>7. Реализацией какого паттерна (шаблона проектирования) являются события в C#?
Декоратор (Decorator)
Посетитель (Visitor)
Издатель-подписчик (Publisher-Subscriber)
Шаблонный метод (Template Method)
<Answer>Рассмотрим пример с кнопкой. Создав объект класса Button, мы подписываемся на его событие Click, которые происходит при нажатии на кнопку. В данном случае, объект Button является издателем (publisher), а тот метод, который подписан на событие, соответственно, подписчиком (subscriber).

<Question>8. Чем отличаются константы и доступные только для чтения поля?
Ничем не отличаются
Константы инициализируются во время компиляции, доступные только для чтения поля — во время выполнения
Доступные только для чтения поля инициализируются во время компиляции, константы — во время выполнения
Константы можно изменять, а доступные только для чтения поля нет
<Answer>Во время компиляции значения констант подставляются в места их использования.

<Question>9. Выберите элементы, которые нельзя пометить атрибутом
Классы
Методы
Структуры
Возвращаемые значения
Интерфейсы
Все перечисленное можно пометить атрибутом
<Answer>Большая часть пользователей не знает правильного ответа на этот вопрос.

Все перечисленные элементы можно найти в типе-перечислении AttributeTargets, значения которого используется в атрибуте AttributeUsage, служащего для указания, что может быть помечено атрибутом.

Пример использования атрибута, примененного к возвращаемому значению:
using System.Runtime.InteropServices;

[DllImport("user32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
internal static extern Boolean MessageBeep(UInt32 uType);

<Question>10. Как называется технология, благодаря которой возможно взаимодействие управляемого кода (managed code) с Win32 API функциями и COM-объектами?
Reflection
Interop
CodeDOM
Remoting
WebServices
<Answer>Существует специальное пространство System.Runtime.InteropServices, в котором находятся классы для работы с неуправляемым кодом, например, хорошо известный атрибут DllImport, для подключения DLL-функций.

<Question>11. Что произойдет при компиляции проекта, где используется класс, структура, интерфейс или перечисление, помеченное атрибутом Obsolete?
Произойдет ошибка компиляции, и проект не будет собран
Будет выведено предупреждение о том, что данный тип устарел, но сборка будет создана
Сборка будет создана, но при запуске произойдет ошибка времени выполнения
Атрибут Obsolete никак не влияет на компиляцию
Нет нужного варианта ответа
<Answer>Атрибутом Obsolete отмечается нерекомендуемая для использования сущность программы. Каждый случай использования сущности, отмеченной устаревшей, будет приводить к генерированию предупреждения или ошибки в зависимости от настроек этого атрибута.

+ADD
Про настройки проекта в вопросе не упомянуто, значит, берём поведение по умолчанию. Указание атрибута: [Obsolete]
На методе в соданном решении, без изменения свойств решения приведёт именно к предупрежению:
public ObsoleteAttribute()
{
    this._message = null;
    this._error = false;
}
 
<Question>12. Перечислите возможности структуры (value-типов)
Реализация интерфейсов
Boxing и Unboxing
Множественное наследование
Наследование от классов
Переопределение конструктора по умолчанию
Определение статического конструктора
Определение индексатора
Использование событий
<Answer>Структуры не поддерживают наследование, но могут реализовывать интерфейсы. Также одной из особенностей является невозможность определения конструктора по умолчанию, так как поля инициализируются значениями по умолчанию автоматически. Но, однако, возможно определение статического конструктора.
 
